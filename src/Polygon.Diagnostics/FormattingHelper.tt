<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ include file="defs.t4" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".Generated.cs" #>

// <auto-generated>
//      This code was generated using T4 text template
//      Generated at <#= DateTime.Now #>
//
//      Changes to this file may cause incorrect behaviour and will be lost 
//      if the code is regenerated.
// </auto-generated>

using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using JetBrains.Annotations;

namespace Polygon.Diagnostics
{
	partial class FormattingHelper
    {
<# foreach(var type in FormattableType.Types) { #>
<#
		if(type.IsReference)
		{
#>
		/// <summary>
		///		Отформатировать значение
		/// </summary>
		public static string Format(<#=type.Name #> value, string format = null) 
		{
			if(ReferenceEquals(value, null))
			{
				return NullStr;
			}

			return <#=type.DefaultFormatter #>;
		}
<#
		}
		else
		{
#>
		/// <summary>
		///		Отформатировать значение
		/// </summary>
		public static string Format(<#=type.Name #> value, string format = null) 
		{
<# if(type.IsFormattable) { #>
			if(format != null)
			{
				return <#=type.CustomFormatter #>;
			}
<# } #>
			return <#=type.DefaultFormatter #>;
		}
<#
			if(type.IsNullable)
			{
#>
		/// <summary>
		///		Отформатировать значение
		/// </summary>
		public static string Format(<#=type.Name #>? nullableValue, string format = null) 
		{
			if(!nullableValue.HasValue)
			{
				return NullStr;
			}

			var value = nullableValue.Value;
<# if(type.IsFormattable) { #>
			if(format != null)
			{
				return <#=type.CustomFormatter #>;
			}
<# } #>
			return <#=type.DefaultFormatter #>;
		}
<#
			}
		}
	} #>


		private static string TryPrintKnownType(object obj, string format)
		{
<#	foreach(var type in FormattableType.Types) { #>
<#		if(type.IsReference) { #>
			var valueOf<#=type.Name #> = obj as <#=type.Name #>;
			if(!ReferenceEquals(valueOf<#=type.Name #>, null))
			{
				return Format(valueOf<#=type.Name #>, format);
			}
<#		} #>
<#		else { #>
<#			if(type.IsNullable) { #>
			if(obj is <#=type.Name #>?)
			{
				return Format((<#=type.Name #>?)obj, format);
			}
<#			} #>
			if(obj is <#=type.Name #>)
			{
				return Format((<#=type.Name #>)obj, format);
			}
<#		} #>
<#	} #>
			return null;
		}
	}
}
<#+
    public sealed class FormattableType
    {
		private FormattableType(string name, string defaultFormatter, string customFormatter, bool isNullable, bool isReference = false) 
		{
			Name             = name;
			DefaultFormatter = defaultFormatter;
			CustomFormatter  = customFormatter;
			IsReference      = isReference;
			IsNullable       = isNullable;
		}

		public string Name              { get; private set; }
		public string DefaultFormatter  { get; private set; }
		public string CustomFormatter   { get; private set; }
		public bool   IsNullable        { get; private set; }
		public bool   IsReference       { get; private set; }
		public bool   IsFormattable     { get { return CustomFormatter != null; } }

		public static readonly FormattableType[] Types = Generate().ToArray();

		private static IEnumerable<FormattableType> Generate() 
		{
			yield return Custom(   "IPrintable", "value.Print(PrintOption.Default)", isReference: true);
			yield return Custom(   "string",     "FormattingHelper.EscapeString(value)");
			yield return Custom(   "bool",       "value ? \"true\" : \"false\"", isNullable: true);

			yield return Primitive("int",        "D");
			yield return Primitive("uint",       "D", "U");
			yield return Primitive("long",       "D", "L");
			yield return Primitive("ulong",      "D", "UL");
			yield return Primitive("short",      "D", "S");
			yield return Primitive("ushort",     "D", "US");
			yield return Primitive("byte",       "D", "B");
			yield return Primitive("sbyte",      "D", "SB");

			yield return Primitive("float",      "F", "f");
			yield return Primitive("double",     "F", "d");
			yield return Primitive("decimal",    "F", "M");
			yield return Primitive("DateTime",   "s");
			yield return Primitive("TimeSpan",   "g");
			yield return Primitive("Guid",       "D");
		}

		private static FormattableType Custom(string type, string formatter, bool isNullable = false, bool isReference = false) 
			=> new FormattableType(type, formatter, null, isNullable, isReference);
		private static FormattableType Primitive(string type, string format, string suffix = "", bool isNullable = true)
		{
			if(string.IsNullOrEmpty(suffix))
			{
				var defaultFormatter = "string.Format(FormatProvider, \"{0:" + format + "}\", value)";
				var customFormatter  = "((IFormattable)value).ToString(format, FormatProvider)";
				return new FormattableType(type, defaultFormatter, customFormatter, isNullable);
			}
			else
			{
				var defaultFormatter = "string.Format(FormatProvider, \"{0:" + format + "}" + suffix + "\", value)";
				var customFormatter  = "((IFormattable)value).ToString(format, FormatProvider) + \"" + suffix + "\"";
				return new FormattableType(type, defaultFormatter, customFormatter, isNullable);
			}
		}
    }
#>
